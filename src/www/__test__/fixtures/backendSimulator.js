import { diff } from "jest-diff";
import { readFile } from "fs/promises";
import path from "path";
import { isEqual } from "underscore";

let postId;
let filePath;
let responsesPromise;
let nextResponseIndex;
let responses;
let closed;

jest.doMock("../../backend", () => {
  const backend = {
    async get(url) {
      const response = await nextResponse({ method: "GET", url });
      return response.body;
    },
  };

  return { backend };
});

export function prepareBackendResponses(currentPostId) {
  nextResponseIndex = 0;

  postId = currentPostId;
  filePath = path.join(
    __dirname,
    "..",
    "..",
    "..",
    "..",
    "target",
    "classes",
    "backendResponses",
    `${postId}.json`
  );

  closed = false;
  responses = null;
  responsesPromise = readFile(filePath, { encoding: "utf8" })
    .then((c) => JSON.parse(c))
    .then((r) => (responses = r));
}

export async function closeBackendResponses() {
  closed = true;
  await responsesPromise;

  if (nextResponseIndex < responses.length) throwSomeResponsesNotConsumed();
}

async function nextResponse(actualRequest) {
  const { request, response } = await nextEntry(actualRequest);

  if (!isEqual(actualRequest, request))
    throwUnexpectedRequest(actualRequest, request);

  return response;
}

async function nextEntry(actualRequest) {
  if (closed) throwResponsesClosed(actualRequest);

  await responsesPromise;
  const responseIndex = nextResponseIndex;
  nextResponseIndex += 1;

  if (nextResponseIndex > responses.length)
    throwTooManyBackendCalls(actualRequest);

  const entry = responses[responseIndex];
  return entry;
}

function throwUnexpectedRequest(actual, expected) {
  throwError(
    `The frontend has done a call to the backend that was not expected. It is not exactly like expected. `,
    `Make sure that the frontend does the same calls that the backend simulates. Correct the frontend, or the backend, as you deem necessary.`,
    `The changes are:`,
    `${diff(expected, actual)}`,
    `The actual request is:`,
    explainRequest(actual),
    `The expected request is:`,
    explainRequest(expected)
  );
}

function throwResponsesClosed(actualRequest) {
  throwError(
    `The test has been finished but there are still some calls to the backend. `,
    `Please, check that you do not forget any await, or you do not have things like array.forEach(async () => ...), they should be await Promise.all(array.map(async () => ...)).`,
    `The current request is:`,
    explainRequest(actualRequest)
  );
}

function throwSomeResponsesNotConsumed() {
  throwError(
    `The frontend has done less calls to the backend than the ones that the backend has simulated in its tests. `,
    `The frontend has done ${nextResponseIndex} calls but the backend has simulated ${responses.length}.`
  );
}

function throwTooManyBackendCalls(actualRequest) {
  throwError(
    `There are more calls to the backend that the ones generated by the backend tests.`,
    `The current request is:`,
    explainRequest(actualRequest)
  );
}

function throwError(...messages) {
  throw new Error(join(messages, explainSituation()));
}

function explainRequest(request) {
  return [
    `- method: ${request.method}`,
    `- url   : ${request.url}`,
    request.body
      ? `- body  : ${JSON.stringify(request.body, null, 2)}`
      : "- body  : does not have body",
  ];
}

function explainSituation() {
  return [
    `The error appeared while executing the test for ${postId}.md. `,
    `The file that contains all the recorded frontend simulations from the backend is at:`,
    `>  ${filePath}`,
    responses && [
      `The file contains the following recorded responses:`,
      responses.map((entry, index) => [
        index < nextResponseIndex - 1 ? "√ " : "ø ",
        `${pad(index + 1)}. ${entry.request.method} ${entry.request.url}`,
      ]),
      nextResponseIndex <= responses.length
        ? `The current recorded response is the ${nextResponseIndex}.`
        : `All recorded responses have been used.`,
    ],
  ];
}

function pad(n) {
  let o = `${n}`;
  while (o.length < 4) o = ` ${o}`;
  return o;
}

function join(...texts) {
  return texts
    .flat(Infinity)
    .filter((x) => x || x === "")
    .map((s) => (s.endsWith(" ") ? s : `${s}\n`))
    .join("");
}
